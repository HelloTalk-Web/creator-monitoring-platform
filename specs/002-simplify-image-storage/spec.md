# Feature Specification: 简化图片存储加载机制

**Feature Branch**: `002-simplify-image-storage`
**Created**: 2025-10-23
**Status**: Draft
**Input**: User description: "基于你上面分析出来的关于完整的图片加载机制，然后还有我们数据库中存储图片的url字段，帮我设计一个比现在干净，简单，高效率的图片存储加载机制，我感觉现在的太复杂了，而且图片url都存了好几个"

## 概述

当前系统的图片存储和加载机制存在复杂性问题：数据库中为每种图片类型存储了多个URL字段（原始URL和本地路径），前端需要处理多种URL来源的逻辑，后端有多个图片处理服务和代理路由。本功能旨在简化整个图片管理流程，通过统一的存储策略和简洁的API接口，提供更高效、易维护的图片加载体验。

## User Scenarios & Testing *(mandatory)*

<!--
  IMPORTANT: User stories should be PRIORITIZED as user journeys ordered by importance.
  Each user story/journey must be INDEPENDENTLY TESTABLE - meaning if you implement just ONE of them,
  you should still have a viable MVP (Minimum Viable Product) that delivers value.
  
  Assign priorities (P1, P2, P3, etc.) to each story, where P1 is the most critical.
  Think of each story as a standalone slice of functionality that can be:
  - Developed independently
  - Tested independently
  - Deployed independently
  - Demonstrated to users independently
-->

### User Story 1 - 开发者集成图片显示 (Priority: P1)

开发者在前端页面需要显示用户头像或视频缩略图时，只需使用一个统一的URL字段，无需关心图片来源是第三方还是本地存储，系统自动处理图片的获取和优化。

**Why this priority**: 这是最核心的用户价值 - 简化开发者的使用体验，直接影响开发效率和代码维护性。

**Independent Test**: 可以通过在前端组件中使用单一图片URL字段来完成测试，验证图片能正确显示且无需额外逻辑处理。

**Acceptance Scenarios**:

1. **Given** 数据库中存储了图片URL，**When** 前端请求该图片，**Then** 图片正确显示，无论其来源是第三方平台还是本地存储
2. **Given** 第三方图片URL失效或无法访问，**When** 前端请求该图片，**Then** 系统返回系统内置的默认占位图（头像返回通用用户图标，缩略图返回播放图标）
3. **Given** 开发者在新页面中添加图片显示，**When** 使用统一的URL字段，**Then** 无需编写URL转换或代理逻辑

---

### User Story 2 - 系统自动优化图片存储 (Priority: P2)

系统自动将所有第三方图片在后台异步下载并存储到本地，后续访问自动使用本地副本，提升加载速度和可靠性。

**Why this priority**: 这是性能优化的关键，能显著提升用户体验，但不阻塞基础功能。

**Independent Test**: 可以通过监控图片首次访问和后续访问的响应时间来验证本地化是否生效。

**Acceptance Scenarios**:

1. **Given** 新爬取的第三方图片URL，**When** 首次被访问，**Then** 系统返回图片并在后台启动下载任务
2. **Given** 图片已完成本地化下载，**When** 再次访问该图片，**Then** 直接从本地存储返回，响应时间少于200毫秒
3. **Given** 任何第三方图片，**When** 被访问，**Then** 系统自动触发后台本地化下载任务

---

### User Story 3 - 数据库迁移和清理 (Priority: P3)

管理员能够安全地从旧的多字段存储模式迁移到新的单字段模式，清理冗余数据，减少存储空间占用。

**Why this priority**: 这是维护和优化任务，不影响核心功能，可以在系统稳定运行后逐步执行。

**Independent Test**: 可以通过执行迁移脚本并验证数据完整性来独立测试。

**Acceptance Scenarios**:

1. **Given** 存在旧格式的图片数据（多个URL字段），**When** 执行迁移脚本，**Then** 系统自动创建备份，数据成功转换为新格式且无数据丢失
2. **Given** 迁移过程中发生错误，**When** 系统检测到迁移失败，**Then** 自动回滚到迁移前的备份点，保持数据一致性
3. **Given** 迁移完成，**When** 清理旧字段，**Then** 数据库存储空间减少且系统功能正常
4. **Given** 迁移过程中，**When** 有新数据写入，**Then** 新数据自动使用新格式存储

---

### Edge Cases

- 当第三方图片URL永久失效时，系统如何处理？
- 当本地存储空间不足时，系统暂停新图片下载并通知管理员手动清理
- 当同一图片URL被多个实体引用时，如何避免重复下载？
- 当图片格式不支持或损坏时，如何返回有意义的错误信息？
- 当批量下载任务失败时，每个失败的图片自动重试最多3次（间隔：1分钟、5分钟、30分钟），记录失败原因供管理员查看

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: 系统必须为每种图片类型（头像、缩略图等）提供统一的URL字段用于前端访问
- **FR-002**: 系统必须将所有第三方图片URL自动本地化（无需判断防盗链或性能需求，统一处理）
- **FR-003**: 系统必须在后台异步下载并存储第三方图片到本地
- **FR-004**: 系统必须为前端提供单一的图片访问接口，自动路由到最优的图片源
- **FR-005**: 系统必须在图片首次访问时立即返回可用的图片（原始URL或代理），同时触发后台下载
- **FR-006**: 系统必须支持图片访问失败时的优雅降级，返回系统内置的默认占位图（头像类型返回通用用户图标，视频缩略图类型返回播放图标）
- **FR-007**: 系统必须记录图片下载失败的原因和次数，失败时自动重试最多3次（使用指数退避：1分钟、5分钟、30分钟），支持管理员手动触发重试
- **FR-008**: 系统必须避免重复下载相同的图片URL
- **FR-009**: 系统必须提供数据库迁移工具，从旧的多字段模式迁移到新的单字段模式，迁移前自动创建数据库备份，出错时自动回滚到备份点
- **FR-010**: 系统必须支持管理员查看图片存储统计信息（总数量、存储空间、命中率等）
- **FR-011**: 系统必须在存储空间不足时暂停新图片下载，并通过日志记录通知管理员触发手动清理（初期使用console.error输出，未来可扩展为邮件或Slack通知）

### Key Entities *(include if feature involves data)*

- **统一图片引用**: 每个需要图片的实体（账号、视频等）只存储一个规范化的图片标识符，系统内部管理其物理存储位置
- **图片元数据**: 记录图片的原始URL、本地存储路径、下载状态、访问次数、最后访问时间等信息
- **下载任务队列**: 管理待下载和失败重试的图片任务，包含优先级、重试次数、失败原因等属性

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: 开发者在前端使用图片时，只需引用一个URL字段，代码复杂度降低至少50%（相比当前实现）
- **SC-002**: 图片加载成功率达到99%以上，包括第三方URL失效时的降级处理
- **SC-003**: 已本地化的图片P95响应时间低于200毫秒（95%的请求在200ms内完成）
- **SC-004**: 数据库中图片相关字段数量从当前的每类型2个减少到1个
- **SC-005**: 图片重复下载率低于5%（每批次下载任务中，通过URL去重机制避免重复下载同一URL）
- **SC-006**: 系统能够在1小时内完成10000张图片的后台下载任务
- **SC-007**: 管理员能够在5分钟内完成数据库迁移脚本的执行和验证

## Clarifications

### Session 2025-10-23

- Q: 当本地存储空间接近限制时，系统应该采用什么清理策略？ → A: 手动清理：当存储空间不足时通知管理员手动清理，系统暂停新图片下载
- Q: 图片下载失败时应该如何重试？ → A: 最多重试3次，使用指数退避（1分钟 → 5分钟 → 30分钟）
- Q: 占位图应该如何提供？ → A: 系统内置默认占位图：不同类型使用不同占位图（头像用通用用户图标，视频缩略图用播放图标）
- Q: 系统应该如何决定哪些图片需要本地化？ → A: 全部本地化：所有第三方图片统一本地化，简化判断逻辑
- Q: 迁移失败或出错时应该如何处理？ → A: 自动回滚：迁移前自动创建数据库备份，出错时回滚到备份点

## Assumptions

- 假设系统有足够的存储空间用于本地化图片
- 假设第三方图片平台的访问策略在合理范围内变化，不会频繁失效
- 假设前端能够处理异步加载和渐进式增强（首次慢，后续快）
- 假设现有的图片下载服务和代理逻辑可以复用或重构
- 假设数据库迁移可以在低峰时段执行，不影响生产环境

## Scope

### In Scope
- 简化数据库图片字段结构
- 统一前端图片访问接口
- 自动化后台图片下载和存储
- 数据迁移工具和脚本
- 图片存储管理和统计

### Out of Scope
- 图片压缩和格式转换（保持原始格式）
- 图片CDN分发（仍使用本地存储）
- 实时图片编辑或裁剪功能
- 用户上传图片的管理（仅针对爬虫获取的图片）
- 历史图片数据的完全重新下载（仅迁移现有数据）
